# Telegram-бот для аналитики по видео на основе задач на естественном языке

## Стек технологий
- Язык: Python 3.11.8 (64 разрядная версия)
- Telegram-бот: aiogram
- База данных: PostgreSQL через ORM библиотеку sqlalchemy
- LLM: GigaChat-2-Max

## Локальное развёртывание проекта
Откройте директорию в которой хотите развернуть проект.
Клонируйте в неё репозиторий проекта
```
git clone https://github.com/BobrPavel/RLT_test_bot.git
```
Создайте виртуальное окружение Pyton и активируйте его
```
python3 -m venv venv  
```
```
venv\Scripts\activate  
```
Проследите, чтобы версия Python была 64 битной!

На данном этапе директория проекта должна выглядеть таким образом:
```
Директория в который вы разварачиваете проект/
├── RLT_test_bot/
    └── ... (файлы backend бота)
└── venv/
    └── ... (файлы виртуального окружения)
```

Установите зависимости
```
pip install -r requirements.txt  
```

Проследите чтобы был выбран правильный интерпритатор Python. Например в VS Code, после открытия файла формата .py 
в левом нижнем углу можно выбрать интерпритатор. У вас должен быть выбран интерпритатор из виртуального окружения.

## Подготовка к локальному запуску бота
После того, как вы развернули бота, в папке RLT_test_bot необходимо создать файл: .env с таким содержимым
```
TOKEN=ваш телеграмм токен
GIGACHAT_CREDENTIALS=ваш ключ к ИИ GigaChat
```
Теперь запустите файл db_script.py Он находится по пути: [RLT_test_bot/database/db_script.py](https://github.com/BobrPavel/RLT_test_bot/blob/main/database/db_script.py) Он создас базу данных
Можете запускать бота через файл [bot.py](https://github.com/BobrPavel/RLT_test_bot/blob/main/bot.py) Содержимое базы данных автоматически загрузится при первом запуске


## Описание архитектуры

Пользователь вводит задачу на естественном русском языке. Aiogram обрабатывает сообщение и оно передаётся ИИ агенту.
ИИ агент анализирует сообщение и формирует JSON QueryPlan, для извлечения данных из БД. С помощью буферного инструмента QueryPlan 
передаётся в исполнитель. Здесь QueryPlan с помощью метрик преобразуется в ORM запрос и выполняется в БД. БД возвращает ответ на запрос, и он передаётся обратно в backend. После всех дейстыий бот отправляет ответ пользователю.

Для надёжности системы, я решил что агент будет формировать QueryPlan, так как если бы он формировал готовый ORM или SQL запрос, то могли возникнуть ошибки.
Так же я применял ORM в исполнении SQLAlhemy, так как на мой взгляд он надежнее и с ним проще реализовать задачу по преобразованию QueryPlan в запрос.

## Описание промпта и взаимодействия с LLM
Для работы с llm применяю такой промпт, который можно увидеть [здесь](https://github.com/BobrPavel/RLT_test_bot/blob/main/common/prompts.py).
Из спицифики принятого подхода, мне не нужно описывать базу данных, вместо этого я концетрируюсь на том как llm должен интепритировать 
естественный язык.
С 3 по 8 строку я строго задаю задачу: Формировать только Json и никак его не менять
Более того, дальше я строго запрещаю что-либо выдумывать и как либо дополнять QueryPlan
Затем передаю пример структуры QueryPlan, где указаны все возможные переменныe
В правилах интерпритации как раз и расписанно как определять операции и параметры фильтрации, а так же указанно что: videos — текущее состояние видео, а video_snapshots — история изменений и delta-поля
В самом конце, я предоставил агенту примеры вопросов пользователя и QueryPlan, которые должны быть сгенерированны в ответ.

## Автор:
Шляпников Павел
- shlapnikovpavel@yandex.com
- [Телеграм:](https://t.me/Bober_Pavel)
- [hh.ru](https://perm.hh.ru/resume/b59f8eafff0dea67980039ed1f3536306a6475)

